# java核心卷I #

- Java的基本程序设计结构
- 对象和类
- 继承
- 接口、lambda表达式与内部类
- 异常、断言和日志
- 泛型程序设计
- 集合
- 图形程序设计
- 事件处理
- Swing用户界面组件
- 部署Java应用程序
- 并发


## Java的基本程序设计结构 ##

- 一个简单的Java应用程序
- 注释
	- //
	- /**/不能嵌套
	- /**  */可以生成文档
- 数据类型
	- 强类型语言，包含8种基本类型
	- 整型
		- int4
		- short2
		- long8
		- byte1
		- 没有无符号类型，字长与平台无关
	- 浮点类型
		- float4
		- double8
			- Double.POSITIVE_INFINITY
			- Double.NEGATIVE_INFINITY
			- Double.NaN
				- Double.isNaN(x)
	- char类型
		- 转义序列的处理在解析代码之前（注释中的\u也会转义）
	- Unicode和char类型
		- 由于char类型对应UTF-16，所以处理复杂，用String处理字符串好很多
	- boolean类型
		- 不能与整型发生类型转换
- 变量
	- 变量初始化
		- 要求显示初始化
		- 声明与定义不作区分
	- 常量
		- final
		- 名称全
- 运算符
	- 数学函数与常量
		- Math类
		- sqrt是一个**静态方法**
		- floorMod负数求余数
		- 静态导入
			- import static java.lang.Math.*;
		- 运算选择
			- 计算机浮点单元例程
			- StrictMath类，自由发布Math库
	- 数值类型之间的转换
		- 隐式转换优先级
			- double
			- float
			- long
			- int
	- 强制类型转换（cast）
		- （int）
		- 四舍五入Math.round（）
	- 结合赋值和运算符
		- +=
		- 如果int与double进行+=，会转换为int
	- 自增与自减运算符
		- n++
	- 关系和boolean运算符
		- 逻辑运算是短路表达式
		- 支持a？b:c
	- 位运算符
	- 括号与运算符级别
	- 枚举类型
		- enum
- 字符串
	- 本质是Unicode字符序列
	- String是一个预定义类
	- 子串
		- sbustring（a,b）
	- 拼接
		- +
		- 与非字符串拼接，会转换为字符串
		- join(定界符)
	- 不可变字符串
		- 字符串不是字符数组，修改字符串用子串+拼接
		- 修改字符串的本质是创建临时对象，然后修改变量指针指向临时对象
		- 修改指针之后，之前在堆里的字符串会被GC回收
	- 检测字符串是否相等
		- equals
		- equalsIgnoreCase
		- ==只会比较指针地址，而不是字符串内容（**不要用==**）
	- 空串与Null串
		- 空串""
		- null代表没有关联对象
	- 码点与代码单元
		- 用来遍历一个字符串
		- 可以生成一个char数组，这个数组可以用于构造string对象
	- string API
	- 阅读联机API文档
	- 构建字符串
		- StringBuilder类
			- append方法
			- toString方法
- 输入输出
	- 读取输入
		- Scanner in = new Scanner(System.in);
		- 创建Scanner对象，并关联标准输入
		- Scanner类
			- nextLine方法
			- next方法
			- nextInt方法
			- nextDouble方法
			- import java.util.*;
		- Console类 读取密码
	- 格式化输出
		- printf
		- 参数索引
	- 文件输入与输出
		- 用File对象创建Scanner
		- PrintWriter类 文件输出
		- 可以使用shell的重定向
- 控制流程
	- 块作用域
		- 不允许定义同名变量
	- 条件语句
	- 循环
	- 确定循环
	- 多重选择则：switch语句
	- 中断控制流程语句
- 大数值
	- BigInteger
	- BigDecimal
- 数组
	- int[] a = new int[100];
	- 元素初始化为0
	- for each循环
	- 数组初始化以及匿名数组
	- 数组拷贝
		- Arrays类
	- 命令行参数
		- arg[0]是第一个参数，不是函数名
	- 数组排序
		- sort方法
	- 多维数组
	- 不规则数组

## 对象与类 ##

- 面向对象程序设计概述
	- 类
	- 对象
	- 识别类
	- 类之间的关系
		- UML
- 使用预定义类
	- 对象与对象变量
		- 构造器
	- Java类库中的LocalDate类
		- Date 时间点
		- LocalDate 日历表示法
	- 更改器方法与访问器方法
		- c++中的普通函数成员
		- c++中的const函数成员
- 用户自定义类
	- Employee类
	- 多个源文件的使用
		- 内置了make，会编译需要的类文件
	- 剖析Employee类
	- 从构造器开始
		- 构造器与new搭配使用
		- 只能用于构造，不能用于修改值
	- 隐式参数与显示参数
		- 会隐式传递this
		- 方法只能定义在类内部，是否内联取决于虚拟机对程序的优化
	- 封装的优点
		- 只允许用自己定义的方法修改对象的状态，所以不要返回可修改的对象
	- 基于类的访问权限
		- 类可以访问自己对象的私有成员
	- 私有方法
	- final实例域
- 静态域与静态方法
	- 静态域
		- 属于类，而不是某个对象
	- 静态常量
		- 是常量
	- 静态方法
		- 不能操作this，通过类名调用
		- static
			- 退出块，仍能存在的局部变量
			- 不能被其他文件访问的全局变量
			- 属于类，不属于对象的变量和函数
	- 工厂方法
		- 静态工厂方法构造对象，调节构造器的局限性
	- main方法
		- 类似于python里的if（__name__ == __main__）
- 方法参数
	- Java中，没有引用传递，想改变对象的状态，就要在函数中调用在函数外声明的变量
- 对象构造
	- 重构
	- 默认域初始化
	- 无参数得到构造器
	- 显示域初始化
	- 参数名
	- 调用另一个构造器
	- 初始化块
	- 对象析构与finalize犯法
		- 类似于析构，但是不可靠
		- 有关闭钩（shutdown hook）
- 包
	- 类的导入
		- 一个类可以使用的类
			- 所属包中的所有类
			- 其他包中的公有类
		- 导入方法
			- 全名
			- import
		- import
			- 与#include完全不同
			- import与namespace、using相同
			- c++不能访问其他文件的内部
			- java可以访问，所以可以用全名去调用公有类
	- 静态导入
		- import static
		- 简写类名，意义不大
	- 将类放入包中
		- 包要和目录匹配
	- 包作用域
- 类路径
	- 设置类路径
- 文档注释
	- 注释的插入
		- 包
		- 公有类与接口
		- 公有的和受保护的构造器及方法
		- 公有的和受保护的域
	- 类注释
	- 方法注释
	- 域注释
	- 通用注释
	- 包与概述注释
	- 注释的抽取
- 类设计技巧

## 继承 ##

- 类、超类和子类
	- 定义子类
		- extends
	- 覆盖方法
		- super
	- 子类构造器
		- super（调用超类中的构造器）
		- 子类不能访问超类中的私有域，只能通过super或者方法
	- 继承层次
		- Java不支持多继承
	- 多态
		- 动态绑定，虚函数
		- 超类变量**可以**被子类赋值
		- 子类变量**不能**被超类赋值
	- 理解方法调用
		- 重载解析，在子类和超类的同名函数的不同参数中寻找最佳匹配，超过1个会报错
		- private、static、final为静态绑定
	- 阻止继承：fianl类和方法
	- 强制类型转换
	- 抽象类
		- 抽象类不能实例化
	- 受保护访问
		- protected，子类可以访问
		- private本类可见
		- public所有类可见
		- 默认 包可见
- Object：所有类的超类
	- 只有基本类型不是对象
	- equals方法
	- 相等测试与继承
	- hashCode方法
	- toString方法
- 泛型数组列表
	- 访问数组列表元素
		- ArrayList<Employee>
	- 类型化与原始数组列表的兼容性
- 对象包装器与自动装箱
- 参数数量可变的方法
- 枚举类
- 反射
	- Class类
	- 捕获异常
	- 利用反射分析类的能力
	- 在运行时使用反射分析对象
	- 使用反射编写泛型数组代码
	- 调用任意方法
- 继承的设计技巧

## 接口、lambda表达式与内部类 ##

- 接口
	- 接口概念
	- 接口的特性
	- 接口与抽象类
	- 静态方法
	- 默认方法
	- 解决默认方法冲突
- 接口示例
	- 接口与毁掉
	- Comparator接口
	- 接口克隆
- lambda表达式
	- 为什么映入lambda表达式
	- lambda表达式的语法
	- 函数是借口
	- 方法引用
	- 构造器引用
	- 变量作用域
	- 处理lambda表达式
	- 再谈Comparator
- 内部类
	- 使用内部类访问对象状态
	- 内部类的特殊语法规则
	- 内部类是否有用、必要和安全
	- 局部内部类
	- 由外部方法访问变量
	- 匿名内部类
	- 静态内部类
- 代理
	- 何时使用代理
	- 创建代理对象
	- 代理类的特性

## 异常、断言和日志 ##

- 处理错误
	- 异常分类
	- 声明受查异常
	- 如何抛出异常
	- 创建异常类
- 捕获异常
	- 捕获异常
	- 捕获多个异常
	- 再次抛出异常与异常链
	- finally子句
	- 带资源的try语句
	- 分析堆栈轨迹元素
- 使用异常机制的技巧
- 使用断言
	- 断言的概念
	- 启用和禁用断言
	- 使用断言完成参数检查
	- 为文档假设使用断言
- 记录日志
	- 基本日志
	- 高级日志
	- 修改日志管理器配置
	- 本地化
	- 处理器
	- 过滤器
	- 格式化器
	- 日志记录说明
- 调试技巧

## 泛型程序设计 ##

- 为什么要使用泛型程序设计
	- 类型参数的好处
	- 谁想成为泛型程序员
- 定义简单泛型类
- 泛型方法
- 类型变量的限定
- 类型代码和虚拟机
	- 类型擦除
	- 翻译泛型表达式
	- 翻译泛型方法
	- 调用遗留代码
- 约束与局限性
	- 不能用基本类型实例化类型参数
	- 运行时类型查询只适用于原始类型
	- 不能创建参数化类型的数组
	- Varargs警告
	- 不能实例化类型变量
	- 不能构造泛型数组
	- 泛型类的静态上下文类型变量无效
	- 不能抛出或捕获泛型类的实例
	- 可以消除对受查异常的检查
	- 注意擦除后的冲突
- 泛型类型的继承规则
- 通配符类型
	- 通配符概念
	- 通配符的超类型限定
	- 无限定通配符
	- 通配符捕获
- 反射和泛型
	- 泛型Class类
	- 使用Class类型参数进行类型匹配
	- 虚拟机中的泛型类型信息

## 集合 ##

- Java集合框架
	- 将集合的接口与实现分离
	- Collection接口
	- 迭代器
	- 泛型实用方法
	- 集合框架中的接口
- 具体的集合
	- 链表
	- 数组列表
	- 散列集
	- 树集
	- 队列与双端队列
	- 优先级队列
- 映射
	- 基本映射操作
	- 更新映射项
	- 映射视图
	- 弱散列映射
	- 链接散列集与映射
	- 枚举集与映射
	- 表示散列映射
- 视图与包装器
	- 轻量级集合包装器
	- 子范围
	- 不可修改的视图
	- 同步视图
	- 受查视图
	- 关旭可选操作的说明
- 算法
	- 排序与混排
	- 二分查找
	- 简单算法
	- 批操作
	- 集合与数组的转换
	- 编写自己的算法
- 遗留的集合
	- Hashtable类
	- 枚举
	- 属性映射
	- 栈
	- 位集

## 图形程序设计 ##

- Swing概述
- 创建框架
- 框架定位
	- 框架属性
	- 确定合适的框架大小
- 在组件中显示信息
- 处理2D图形
- 使用颜色
- 文本使用特殊字体
- 显示图像

## 事件处理 ##

- 事件处理基础
	- 实例：处理按钮点击事件
	- 简介地指定监听器
	- 实例：改变观感
	- 适配器类
- 动作
- 鼠标事件
- AWT事件继承层次
	- 语义事件和底层事件

## Swing用户界面组件 ##

- Swing和模型-视图-控制器设计模式
- 布局管理概述
- 文本输入
- 选择组件
- 菜单
- 复杂的布局管理
- 对话框
- GUI程序排错

## 部署Java应用程序 ##

- JAR文件
- 应用首选项的存储
- 服务加载器
- applet
- Java Web Start

## 并发 ##

- 什么是线程
- 中断线程
- 线程状态
- 线程属性
- 同步
- 阻塞队列
- 线程安全的集合
- Callable和Future
- 执行器
- 同步器
- 线程与Swing
- 

